PASSOS CRIAÇÃO DE CRUD

Para criar um CRUD em Progress 4GL (também chamado de OpenEdge ABL) que pode ser consumido por um projeto Angular, você precisará desenvolver um backend em Progress que expõe APIs RESTful para operações de CRUD (Create, Read, Update, Delete). Essas APIs poderão ser consumidas pelo frontend Angular. Abaixo estão os passos gerais para realizar isso:

1. Configurar o ambiente OpenEdge para serviços REST
Você precisará configurar um servidor de aplicações Progress que suporte REST. Isso pode ser feito por meio do Progress OpenEdge WebSpeed ou usando o OpenEdge Application Server (PAS) for OpenEdge.

PAS for OpenEdge é preferível, pois tem suporte nativo para REST.
Defina um serviço REST que irá expor os endpoints.

2. Criar o CRUD em Progress 4GL (ABL)
Aqui está um exemplo de código Progress 4GL para criar operações básicas de CRUD para uma tabela chamada Customer.

a. Create (POST)
progress
Copiar código
DEFINE INPUT PARAMETER pCustomerName AS CHARACTER NO-UNDO.
DEFINE INPUT PARAMETER pCustomerEmail AS CHARACTER NO-UNDO.
DEFINE OUTPUT PARAMETER pStatus AS CHARACTER NO-UNDO.

CREATE Customer.
ASSIGN Customer.CustomerName = pCustomerName
       Customer.CustomerEmail = pCustomerEmail.

IF AVAILABLE Customer THEN
    pStatus = "Success".
ELSE
    pStatus = "Failure".
b. Read (GET)
progress
Copiar código
DEFINE INPUT PARAMETER pCustomerID AS INTEGER NO-UNDO.
DEFINE OUTPUT PARAMETER pCustomerName AS CHARACTER NO-UNDO.
DEFINE OUTPUT PARAMETER pCustomerEmail AS CHARACTER NO-UNDO.
DEFINE OUTPUT PARAMETER pStatus AS CHARACTER NO-UNDO.

FIND Customer WHERE Customer.CustomerID = pCustomerID NO-LOCK NO-ERROR.

IF AVAILABLE Customer THEN DO:
    pCustomerName = Customer.CustomerName.
    pCustomerEmail = Customer.CustomerEmail.
    pStatus = "Success".
END.
ELSE DO:
    pStatus = "Customer not found".
END.
c. Update (PUT)
progress
Copiar código
DEFINE INPUT PARAMETER pCustomerID AS INTEGER NO-UNDO.
DEFINE INPUT PARAMETER pCustomerName AS CHARACTER NO-UNDO.
DEFINE INPUT PARAMETER pCustomerEmail AS CHARACTER NO-UNDO.
DEFINE OUTPUT PARAMETER pStatus AS CHARACTER NO-UNDO.

FIND Customer WHERE Customer.CustomerID = pCustomerID EXCLUSIVE-LOCK NO-ERROR.

IF AVAILABLE Customer THEN DO:
    ASSIGN Customer.CustomerName = pCustomerName
           Customer.CustomerEmail = pCustomerEmail.
    pStatus = "Success".
END.
ELSE DO:
    pStatus = "Customer not found".
END.
d. Delete (DELETE)
progress
Copiar código
DEFINE INPUT PARAMETER pCustomerID AS INTEGER NO-UNDO.
DEFINE OUTPUT PARAMETER pStatus AS CHARACTER NO-UNDO.

FIND Customer WHERE Customer.CustomerID = pCustomerID EXCLUSIVE-LOCK NO-ERROR.

IF AVAILABLE Customer THEN DO:
    DELETE Customer.
    pStatus = "Success".
END.
ELSE DO:
    pStatus = "Customer not found".
END.
3. Criar serviços REST no Progress
Utilize o OpenEdge Developer Studio para criar um novo serviço REST.
Crie métodos para os endpoints HTTP (GET, POST, PUT, DELETE) e associe-os ao código ABL acima.
Configure o mapeamento de URIs (por exemplo, /customer/{id}) e defina o tipo de dados de entrada/saída como JSON.
4. Testar os endpoints REST
Use ferramentas como Postman ou cURL para testar os endpoints REST que você criou e verificar se as operações de CRUD estão funcionando corretamente.

5. Consumir os serviços REST no Angular
Agora que o backend está pronto, você pode criar um serviço no Angular para consumir essas APIs. Aqui está um exemplo básico de como criar o serviço em Angular para consumir os endpoints.

a. Criar um serviço Angular
typescript
Copiar código
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class CustomerService {

  private apiUrl = 'http://localhost:8080/rest/customer';

  constructor(private http: HttpClient) { }

  // Get customer by ID
  getCustomer(id: number): Observable<any> {
    return this.http.get(`${this.apiUrl}/${id}`);
  }

  // Create new customer
  createCustomer(customer: any): Observable<any> {
    return this.http.post(this.apiUrl, customer);
  }

  // Update customer
  updateCustomer(id: number, customer: any): Observable<any> {
    return this.http.put(`${this.apiUrl}/${id}`, customer);
  }

  // Delete customer
  deleteCustomer(id: number): Observable<any> {
    return this.http.delete(`${this.apiUrl}/${id}`);
  }
}
b. Component Angular para CRUD
Crie componentes Angular que utilizem o serviço para interagir com a interface e chamar as APIs REST.

Conclusão
Com o Progress 4GL (ABL) você cria o backend de CRUD exposto como APIs REST, que o Angular pode consumir facilmente. O fluxo geral envolve:

Criar lógica de CRUD em Progress.
Expor essa lógica como serviços REST.
Consumir os serviços REST no Angular através de HTTP requests.



Configurar o OpenEdge Application Server (PAS) for OpenEdge é uma etapa essencial para expor serviços REST que o frontend (por exemplo, um projeto Angular) pode consumir. O PAS for OpenEdge é a plataforma de middleware da Progress que permite rodar aplicações ABL e também disponibilizá-las como serviços REST, SOAP ou outros protocolos de comunicação.

Objetivo da configuração
O objetivo de configurar o PAS for OpenEdge é criar um ambiente no qual suas aplicações Progress 4GL possam ser acessadas via HTTP, permitindo que o frontend (Angular ou qualquer outro) realize operações CRUD através de APIs REST.

Etapas detalhadas de configuração do PAS for OpenEdge
1. Instalar o PAS for OpenEdge
Se ainda não tiver o PAS for OpenEdge instalado, siga esses passos:

Baixe o instalador do PAS for OpenEdge da Progress.
Durante a instalação, selecione a opção de instalar o PAS for OpenEdge (Progress Application Server).
Após a instalação, verifique se o PAS está funcionando. Normalmente, ele estará disponível em http://localhost:8810 (porta padrão) ou na porta configurada durante a instalação.
2. Criar uma nova instância do PAS
Depois de instalar o PAS, o próximo passo é criar uma nova instância de servidor que possa ser usada para hospedar seus serviços REST.

Comando para criar uma nova instância:
Abra o Proenv (Prompt de comando Progress) e execute o seguinte comando:

bash
Copiar código
tcman create myPasInstance
Esse comando criará uma nova instância chamada myPasInstance. Após a criação, inicie a instância:

bash
Copiar código
tcman start myPasInstance
Isso fará com que o servidor esteja disponível em http://localhost:<porta>/myPasInstance.

3. Configurar o OpenEdge Web Server para Suporte a REST
O PAS for OpenEdge precisa ser configurado para suportar serviços REST. Isso é feito através do OpenEdge Management ou diretamente nos arquivos de configuração.

a. Configurar via OpenEdge Explorer
Abra o OpenEdge Management/Explorer (geralmente acessível em http://localhost:9090/).
No menu à esquerda, localize sua instância do PAS criada (myPasInstance).
Vá até a aba Web Applications e clique em Add para adicionar um novo módulo Web.
Selecione o tipo REST como o tipo de aplicação web.
Mapeie seu aplicativo REST para um nome de contexto que será usado nas URLs (exemplo: /rest).
b. Configurar via Arquivo de Configuração
Você também pode configurar diretamente no arquivo OpenEdge.properties, que é encontrado no diretório da instância myPasInstance.

Localize a seção de configurações REST e ajuste conforme necessário.
Certifique-se de que as propriedades de REST estão ativadas e apontando para o correto ABL Service/Program.
4. Criar um Serviço REST no OpenEdge Developer Studio
Agora que o PAS for OpenEdge está configurado, você pode usar o OpenEdge Developer Studio para criar os serviços REST.

Passos para criar um serviço REST:
Criar um Projeto OpenEdge: No OpenEdge Developer Studio, crie um novo projeto ABL.
Criar Classes e Procedimentos ABL: Escreva o código ABL (Progress 4GL) que implementa a lógica de CRUD, como descrito anteriormente (Create, Read, Update, Delete).
Adicionar um Serviço REST:
Clique com o botão direito no projeto e vá em New > REST Service.
Escolha a opção de gerar um serviço REST baseado em um procedimento ABL ou uma classe ABL.
Defina as rotas URI (por exemplo, /customer/{id} para acessar um cliente).
Configurar o Mapeamento de Dados:
No REST Manager, você pode mapear os parâmetros de entrada e saída (tipicamente em formato JSON) para os parâmetros ABL.
Implantar o Serviço:
Após definir o serviço REST, você pode implantá-lo na instância do PAS for OpenEdge (ex: myPasInstance).
5. Testar o Serviço REST
Use ferramentas como Postman ou cURL para testar as operações CRUD expostas por suas APIs REST. Por exemplo, você pode fazer uma requisição GET para http://localhost:8810/myPasInstance/rest/customer/1 para recuperar um cliente com ID 1.

Exemplo de requisição cURL:

bash
Copiar código
curl -X GET http://localhost:8810/myPasInstance/rest/customer/1
6. Configurar o Cross-Origin Resource Sharing (CORS)
Se você estiver consumindo essas APIs a partir de um frontend Angular hospedado em um domínio diferente, precisará garantir que o CORS (Cross-Origin Resource Sharing) esteja ativado no PAS for OpenEdge.

No OpenEdge Explorer, vá até a configuração de Web Application.
Ative o CORS e defina as regras para permitir que seu frontend Angular faça requisições às APIs REST.
7. Desenvolvimento Adicional e Manutenção
Agora que seu PAS for OpenEdge está configurado e expõe serviços REST, você pode continuar desenvolvendo novas funcionalidades no backend em Progress 4GL, e essas mudanças estarão imediatamente disponíveis para o frontend Angular consumir via as APIs REST que você configurou.

Conclusão
Configurar o PAS for OpenEdge é um passo necessário para criar APIs REST que serão consumidas por projetos Angular ou outras interfaces. Esse servidor de aplicações possibilita a execução de código ABL de forma acessível via HTTP, e sua configuração garante que operações de CRUD possam ser acessadas e utilizadas por diferentes interfaces e plataformas.





-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Para criar um backend em Progress 4GL (OpenEdge ABL), é importante seguir boas práticas de modularização e organização do código. Assim como em outras linguagens, você pode optar por diferentes abordagens para estruturar as operações CRUD (Create, Read, Update, Delete). A estruturação ideal depende do tamanho e da complexidade do projeto, mas há algumas convenções e práticas recomendadas que podem ser seguidas.

Opções de Estruturação de CRUD em Progress 4GL
Você pode organizar as operações de CRUD de duas formas principais:

Procedures separadas por operação:

Cada operação (Create, Read, Update, Delete) é implementada em uma procedure separada.
Cada procedure pode ser armazenada em um arquivo distinto para promover uma separação clara de responsabilidades.

Procedures agrupadas em um arquivo só:

Todas as operações CRUD para uma entidade (ou tabela) podem ser agrupadas em um único arquivo. Neste caso, todas as funções relacionadas a uma entidade específica são mantidas juntas, facilitando a visualização de toda a lógica daquela entidade.




Convenção e Boas Práticas Utilizadas

1. Separação por Camadas (Camada de Negócio e Acesso a Dados)
Uma abordagem comum em arquiteturas de backends modernos é dividir o código em camadas:

Camada de Acesso a Dados (Data Access Layer - DAL): Essa camada é responsável pelas interações diretas com o banco de dados, ou seja, onde as operações de CRUD acontecem.
Camada de Negócio (Business Logic Layer - BLL): Aqui, as regras de negócio são aplicadas. Essa camada utiliza a camada de acesso a dados, mas não interage diretamente com o banco.
Camada de Apresentação ou API (Presentation Layer): Aqui você define como os dados serão expostos (via API, por exemplo) ou como as interfaces interagem com o backend.
Esse padrão de camadas facilita a manutenção, testabilidade e escalabilidade da aplicação.

2. Procedures Agrupadas por Entidade
Uma convenção comum é agrupar as procedures CRUD de cada entidade em um único arquivo, mas com diferentes procedures para cada operação. Por exemplo, para uma entidade Cliente, você teria um arquivo cliente.p contendo as seguintes procedures:

progress
Copiar código
PROCEDURE createCliente:
    /* Código para criar um cliente */
END.

PROCEDURE readCliente:
    /* Código para ler um cliente */
END.

PROCEDURE updateCliente:
    /* Código para atualizar um cliente */
END.

PROCEDURE deleteCliente:
    /* Código para deletar um cliente */
END.
Dessa forma, todas as operações relacionadas à entidade Cliente ficam no mesmo arquivo, promovendo uma melhor organização e facilitando a manutenção.


3. Separação de Procedures por Função (Por Operação CRUD)
Outra abordagem possível é criar arquivos separados para cada operação CRUD. Isso é útil em grandes sistemas ou quando as operações são muito complexas. Por exemplo:

cliente_create.p: Contém a lógica de criação de cliente.
cliente_read.p: Contém a lógica para leitura de cliente.
cliente_update.p: Contém a lógica para atualização de cliente.
cliente_delete.p: Contém a lógica para deletar cliente.

Essa abordagem favorece ainda mais a modularidade e facilita a manutenção de partes específicas do sistema, já que cada arquivo se concentra em uma única responsabilidade.



Estruturação Correta de uma Aplicação Backend em Progress 4GL
1. Estrutura de Diretórios Sugerida
Para organizar adequadamente uma aplicação backend, a seguinte estrutura de diretórios pode ser utilizada:

bash
Copiar código
/backend
    /src
        /business (ou /bll)  -> Camada de negócios
            cliente_negocio.p
            produto_negocio.p
        /data (ou /dal)  -> Camada de acesso a dados
            cliente.p
            produto.p
        /api  -> Exposição da API (se houver)
            cliente_api.p
            produto_api.p
    /test  -> Testes
        cliente_test.p
        produto_test.p
    /config  -> Configurações (se necessário)
        database-config.p
Essa estrutura facilita o desenvolvimento em grandes equipes e torna o código mais claro.


2. Exemplo de Procedures para Operações CRUD
Aqui está um exemplo de como organizar um CRUD simples em Progress 4GL para a entidade Cliente:

Camada de Acesso a Dados (DAL) (src/data/cliente.p)
progress
Copiar código
/* Procedure para Criar Cliente */
PROCEDURE createCliente:
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    CREATE cliente.
    ASSIGN
        cliente.nome = nome
        cliente.idade = idade.
    /* Salva no banco de dados */
    SAVE TRANSACTION.
END.

/* Procedure para Ler Cliente */
PROCEDURE readCliente:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.
    DEFINE OUTPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE OUTPUT PARAMETER idade AS INTEGER NO-UNDO.

    FIND cliente WHERE cliente.id = id NO-ERROR.
    IF AVAILABLE cliente THEN DO:
        nome = cliente.nome.
        idade = cliente.idade.
    END.
END.
Camada de Negócio (BLL) (src/business/cliente_negocio.p)
Aqui você adicionaria validações, cálculos ou outras lógicas de negócio:

progress
Copiar código
PROCEDURE criarClienteComValidacao:
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    IF nome = "" THEN RETURN ERROR "Nome não pode ser vazio.".
    IF idade < 18 THEN RETURN ERROR "Idade mínima é 18 anos.".

    /* Chama a camada de acesso a dados */
    RUN createCliente (INPUT nome, INPUT idade).
END.
Camada de API (Exposição da Lógica) (src/api/cliente_api.p)
Essa camada serve para expor os dados de forma que possam ser acessados por um front-end ou outra aplicação. Se fosse uma API REST, você poderia criar uma lógica que respondesse às chamadas HTTP.

progress
Copiar código
PROCEDURE createClienteAPI:
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.
    
    /* Chama a lógica de negócio */
    RUN criarClienteComValidacao(INPUT nome, INPUT idade).

    /* Retorna sucesso ou erro */
    RETURN "Cliente criado com sucesso!".
END.

Conclusão
Modularize o CRUD por entidade: Coloque as operações de CRUD relacionadas a uma entidade (como cliente, produto) juntas, seja em um único arquivo ou separadas por operações.
Use separação por camadas: Separe a lógica de negócio da lógica de acesso a dados e da interface com o usuário ou API, facilitando a manutenção e escalabilidade.
Siga boas práticas de organização: Uma estrutura de diretórios bem planejada ajuda a manter o código organizado e fácil de entender, especialmente em projetos maiores.
Essa abordagem modular e baseada em camadas é uma das convenções mais utilizadas e eficientes para o desenvolvimento de um backend em Progress 4GL.
















Vamos criar um exemplo completo de um CRUD para uma entidade chamada Cliente em Progress 4GL (OpenEdge ABL), seguindo as boas práticas de modularização que mencionei anteriormente. A estrutura do código será organizada em camadas, com arquivos separados para as operações de Create, Read, Update e Delete, bem como uma camada de negócio para regras e validações.

Estrutura de Diretórios
Aqui está uma estrutura de diretórios simples para o nosso CRUD:

rust
Copiar código
/backend
    /src
        /business
            cliente_negocio.p   -> Camada de negócios
        /data
            cliente_create.p    -> Criar Cliente
            cliente_read.p      -> Ler Cliente
            cliente_update.p    -> Atualizar Cliente
            cliente_delete.p    -> Deletar Cliente
        /api
            cliente_api.p       -> Exposição da API (CRUD)
1. Camada de Acesso a Dados (DAL)
Aqui, teremos os arquivos responsáveis pelas operações diretamente no banco de dados, como criação, leitura, atualização e exclusão de clientes.

1.1 cliente_create.p
progress
Copiar código
/* Arquivo: /src/data/cliente_create.p */
PROCEDURE createCliente:
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    /* Cria um novo registro na tabela 'cliente' */
    CREATE cliente.
    ASSIGN
        cliente.nome = nome
        cliente.idade = idade.

    /* Salva no banco de dados */
    SAVE TRANSACTION.

    MESSAGE "Cliente criado com sucesso!" VIEW-AS ALERT-BOX.
END.
1.2 cliente_read.p
progress
Copiar código
/* Arquivo: /src/data/cliente_read.p */
PROCEDURE readCliente:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.
    DEFINE OUTPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE OUTPUT PARAMETER idade AS INTEGER NO-UNDO.

    FIND cliente WHERE cliente.id = id NO-ERROR.

    IF AVAILABLE cliente THEN DO:
        nome = cliente.nome.
        idade = cliente.idade.
    END.
    ELSE DO:
        MESSAGE "Cliente não encontrado!" VIEW-AS ALERT-BOX.
    END.
END.
1.3 cliente_update.p
progress
Copiar código
/* Arquivo: /src/data/cliente_update.p */
PROCEDURE updateCliente:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    FIND cliente WHERE cliente.id = id NO-ERROR.

    IF AVAILABLE cliente THEN DO:
        ASSIGN
            cliente.nome = nome
            cliente.idade = idade.
        SAVE TRANSACTION.
        MESSAGE "Cliente atualizado com sucesso!" VIEW-AS ALERT-BOX.
    END.
    ELSE DO:
        MESSAGE "Cliente não encontrado!" VIEW-AS ALERT-BOX.
    END.
END.
1.4 cliente_delete.p
progress
Copiar código
/* Arquivo: /src/data/cliente_delete.p */
PROCEDURE deleteCliente:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.

    FIND cliente WHERE cliente.id = id NO-ERROR.

    IF AVAILABLE cliente THEN DO:
        DELETE cliente.
        SAVE TRANSACTION.
        MESSAGE "Cliente deletado com sucesso!" VIEW-AS ALERT-BOX.
    END.
    ELSE DO:
        MESSAGE "Cliente não encontrado!" VIEW-AS ALERT-BOX.
    END.
END.
2. Camada de Negócio (BLL)
Aqui, vamos adicionar uma camada de negócios para gerenciar a validação e regras que podem ser aplicadas ao cliente antes de interagir com a camada de dados.

cliente_negocio.p
progress
Copiar código
/* Arquivo: /src/business/cliente_negocio.p */
PROCEDURE criarClienteComValidacao:
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    /* Validações */
    IF nome = "" THEN DO:
        RETURN ERROR "Nome do cliente não pode ser vazio.".
    END.
    IF idade < 18 THEN DO:
        RETURN ERROR "Idade mínima do cliente deve ser 18 anos.".
    END.

    /* Chama a camada de dados para criar o cliente */
    RUN createCliente (INPUT nome, INPUT idade).
END.

PROCEDURE atualizarClienteComValidacao:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    /* Validações */
    IF nome = "" THEN DO:
        RETURN ERROR "Nome do cliente não pode ser vazio.".
    END.
    IF idade < 18 THEN DO:
        RETURN ERROR "Idade mínima do cliente deve ser 18 anos.".
    END.

    /* Chama a camada de dados para atualizar o cliente */
    RUN updateCliente (INPUT id, INPUT nome, INPUT idade).
END.
3. Camada de API (Exposição da Lógica)
Aqui você cria uma API que expõe as operações CRUD para outras partes do sistema ou para interfaces externas.

cliente_api.p
progress
Copiar código
/* Arquivo: /src/api/cliente_api.p */

/* API para Criar Cliente */
PROCEDURE createClienteAPI:
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    /* Chama a lógica de negócios para validar e criar o cliente */
    RUN criarClienteComValidacao (INPUT nome, INPUT idade).
END.

/* API para Ler Cliente */
PROCEDURE readClienteAPI:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.
    DEFINE OUTPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE OUTPUT PARAMETER idade AS INTEGER NO-UNDO.

    /* Chama a camada de dados para ler o cliente */
    RUN readCliente (INPUT id, OUTPUT nome, OUTPUT idade).
END.

/* API para Atualizar Cliente */
PROCEDURE updateClienteAPI:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.
    DEFINE INPUT PARAMETER nome AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER idade AS INTEGER NO-UNDO.

    /* Chama a lógica de negócios para validar e atualizar o cliente */
    RUN atualizarClienteComValidacao (INPUT id, INPUT nome, INPUT idade).
END.

/* API para Deletar Cliente */
PROCEDURE deleteClienteAPI:
    DEFINE INPUT PARAMETER id AS INTEGER NO-UNDO.

    /* Chama a camada de dados para deletar o cliente */
    RUN deleteCliente (INPUT id).
END.
Resumo
Camada de Dados (DAL): Implementa diretamente as operações de Create, Read, Update e Delete no banco de dados.
Camada de Negócio (BLL): Contém validações e regras de negócio antes de realizar operações no banco de dados.
Camada de API: Exposição das operações CRUD para serem consumidas por outras partes da aplicação ou por sistemas externos.
Essa estrutura promove modularidade, clareza e reusabilidade do código, facilitando tanto a manutenção quanto a expansão do sistema ao longo do tempo.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Para implementar um CRUD (Create, Read, Update, Delete) em OpenEdge ABL, você pode seguir o exemplo abaixo. Neste caso, vamos criar uma tabela simples chamada clientes, que terá os campos id, nome, e email.

1. Criar a Tabela clientes
Primeiro, você precisa garantir que a tabela clientes exista no seu banco de dados. Você pode criar a tabela usando o seguinte comando SQL:

sql
Copiar código
CREATE TABLE clientes (
    id INTEGER PRIMARY KEY,
    nome VARCHAR(100),
    email VARCHAR(100)
);
2. Criar o Programa ABL
Agora, vamos criar um programa em ABL que executa as operações CRUD.

abl
Copiar código
DEFINE VARIABLE cNome AS CHARACTER NO-UNDO.
DEFINE VARIABLE cEmail AS CHARACTER NO-UNDO.
DEFINE VARIABLE iId AS INTEGER NO-UNDO.
DEFINE VARIABLE hCliente AS HANDLE NO-UNDO.

DEFINE TEMP-TABLE ttCliente NO-UNDO
    FIELD id AS INTEGER
    FIELD nome AS CHARACTER
    FIELD email AS CHARACTER.

DEFINE QUERY qCliente FOR ttCliente.

CREATE CLIENT-DB.

PROCEDURE CreateCliente:
    DEFINE INPUT PARAMETER cNome AS CHARACTER.
    DEFINE INPUT PARAMETER cEmail AS CHARACTER.
    
    CREATE ttCliente.
    ASSIGN
        ttCliente.id = NEXT-VALUE hCliente:idSequence
        ttCliente.nome = cNome
        ttCliente.email = cEmail.

    DISPLAY "Cliente criado: " ttCliente.nome.
END PROCEDURE.

PROCEDURE ReadCliente:
    DEFINE INPUT PARAMETER iId AS INTEGER.
    
    FIND FIRST ttCliente WHERE ttCliente.id = iId NO-ERROR.
    
    IF NOT VALID-HANDLE( ttCliente ) THEN DO:
        DISPLAY "Cliente não encontrado.".
    END.
    ELSE DO:
        DISPLAY "ID: " ttCliente.id 
                "Nome: " ttCliente.nome 
                "Email: " ttCliente.email.
    END.
END PROCEDURE.

PROCEDURE UpdateCliente:
    DEFINE INPUT PARAMETER iId AS INTEGER.
    DEFINE INPUT PARAMETER cNome AS CHARACTER.
    DEFINE INPUT PARAMETER cEmail AS CHARACTER.
    
    FIND FIRST ttCliente WHERE ttCliente.id = iId NO-ERROR.
    
    IF NOT VALID-HANDLE( ttCliente ) THEN DO:
        DISPLAY "Cliente não encontrado.".
    END.
    ELSE DO:
        ASSIGN
            ttCliente.nome = cNome
            ttCliente.email = cEmail.
        DISPLAY "Cliente atualizado: " ttCliente.nome.
    END.
END PROCEDURE.

PROCEDURE DeleteCliente:
    DEFINE INPUT PARAMETER iId AS INTEGER.
    
    FIND FIRST ttCliente WHERE ttCliente.id = iId NO-ERROR.
    
    IF NOT VALID-HANDLE( ttCliente ) THEN DO:
        DISPLAY "Cliente não encontrado.".
    END.
    ELSE DO:
        DELETE ttCliente.
        DISPLAY "Cliente deletado: " iId.
    END.
END PROCEDURE.

3. Chamar as Funções CRUD
Você pode chamar as funções criadas para realizar operações CRUD como mostrado abaixo:

abl
Copiar código
/* Criar cliente */
RUN CreateCliente("João da Silva", "joao@example.com").

/* Ler cliente */
RUN ReadCliente(1).

/* Atualizar cliente */
RUN UpdateCliente(1, "João da Silva", "joao.novo@example.com").

/* Deletar cliente */
RUN DeleteCliente(1).
Observações
Ajuste de Dados: Certifique-se de ajustar os dados conforme necessário para que correspondam ao seu ambiente.
Erro de Manipulação: Considere implementar mais manipulação de erros para lidar com situações inesperadas.
Transações: Para operações que alteram dados, como Create, Update, e Delete, considere usar transações para garantir a integridade dos dados.
Ambiente: Este código deve ser executado em um ambiente que tenha OpenEdge ABL configurado.
Com este exemplo, você pode implementar um CRUD básico em OpenEdge ABL. Se precisar de mais detalhes ou ajuda, é só avisar!






Você disse:
como expor para ser consumida pelo front end?
O ChatGPT disse:
ChatGPT
Para expor um CRUD em OpenEdge ABL para que possa ser consumido por um front-end, você precisará criar uma API (Interface de Programação de Aplicações) RESTful. A seguir, explico as etapas necessárias para implementar isso.

1. Preparar o Ambiente
Certifique-se de ter o OpenEdge 11 ou superior, que possui suporte nativo para criar serviços REST. Você precisará do OpenEdge Application Server e do Progress Developer Studio.

2. Criar um WebService
A forma mais comum de expor um CRUD é através de um Web Service. O OpenEdge ABL pode ser usado para criar um Web Service REST usando o seguinte procedimento.

Exemplo de um Web Service RESTful
Criar o arquivo .p para o Web Service:
abl
Copiar código
DEFINE VARIABLE hRequest  AS HANDLE NO-UNDO.
DEFINE VARIABLE hResponse AS HANDLE NO-UNDO.
DEFINE VARIABLE cOutput   AS CHARACTER NO-UNDO.

DEFINE TEMP-TABLE ttCliente NO-UNDO
    FIELD id AS INTEGER
    FIELD nome AS CHARACTER
    FIELD email AS CHARACTER.

DEFINE QUERY qCliente FOR ttCliente.

PROCEDURE getClientes:
    FOR EACH ttCliente:
        ASSIGN cOutput = cOutput + STRING(ttCliente.id) + "," + ttCliente.nome + "," + ttCliente.email + "; ".
    END.
    RETURN cOutput.
END PROCEDURE.

PROCEDURE getCliente:
    DEFINE INPUT PARAMETER iId AS INTEGER.
    DEFINE VARIABLE cOutput AS CHARACTER NO-UNDO.
    
    FIND FIRST ttCliente WHERE ttCliente.id = iId NO-ERROR.
    
    IF NOT VALID-HANDLE(ttCliente) THEN
        RETURN "Cliente não encontrado.".
        
    cOutput = STRING(ttCliente.id) + "," + ttCliente.nome + "," + ttCliente.email.
    RETURN cOutput.
END PROCEDURE.

PROCEDURE createCliente:
    DEFINE INPUT PARAMETER cNome AS CHARACTER.
    DEFINE INPUT PARAMETER cEmail AS CHARACTER.
    
    CREATE ttCliente.
    ASSIGN
        ttCliente.nome = cNome
        ttCliente.email = cEmail.
        
    RETURN "Cliente criado: " + cNome.
END PROCEDURE.

PROCEDURE updateCliente:
    DEFINE INPUT PARAMETER iId AS INTEGER.
    DEFINE INPUT PARAMETER cNome AS CHARACTER.
    DEFINE INPUT PARAMETER cEmail AS CHARACTER.
    
    FIND FIRST ttCliente WHERE ttCliente.id = iId NO-ERROR.
    
    IF NOT VALID-HANDLE(ttCliente) THEN
        RETURN "Cliente não encontrado.".
        
    ASSIGN
        ttCliente.nome = cNome
        ttCliente.email = cEmail.
        
    RETURN "Cliente atualizado: " + cNome.
END PROCEDURE.

PROCEDURE deleteCliente:
    DEFINE INPUT PARAMETER iId AS INTEGER.
    
    FIND FIRST ttCliente WHERE ttCliente.id = iId NO-ERROR.
    
    IF NOT VALID-HANDLE(ttCliente) THEN
        RETURN "Cliente não encontrado.".
        
    DELETE ttCliente.
    RETURN "Cliente deletado: " + STRING(iId).
END PROCEDURE.

DEFINE PUBLIC PROCEDURE api:
    DEFINE INPUT PARAMETER cMethod AS CHARACTER.
    DEFINE INPUT PARAMETER cBody AS CHARACTER NO-UNDO.
    DEFINE VARIABLE cResponse AS CHARACTER NO-UNDO.
    
    IF cMethod = "GET" THEN DO:
        IF cBody = "" THEN 
            cResponse = getClientes().
        ELSE 
            cResponse = getCliente(STRING(cBody)).
    END.
    ELSE IF cMethod = "POST" THEN DO:
        DEFINE VARIABLE cNome AS CHARACTER NO-UNDO.
        DEFINE VARIABLE cEmail AS CHARACTER NO-UNDO.
        /* Parse cBody para obter cNome e cEmail */
        cResponse = createCliente(cNome, cEmail).
    END.
    ELSE IF cMethod = "PUT" THEN DO:
        DEFINE VARIABLE iId AS INTEGER NO-UNDO.
        /* Parse cBody para obter iId, cNome e cEmail */
        cResponse = updateCliente(iId, cNome, cEmail).
    END.
    ELSE IF cMethod = "DELETE" THEN DO:
        cResponse = deleteCliente(STRING(cBody)).
    END.

    RETURN cResponse.
END PROCEDURE.
Publicar o Web Service:
Utilize o OpenEdge AppServer para publicar o Web Service e configure as propriedades necessárias no arquivo de configuração do AppServer.
Garanta que seu OpenEdge está configurado para escutar requisições REST.

https://docs.progress.com/pt-BR/bundle/openedge-data-objects-guide/page/CRUD-examples.html